#!/usr/bin/env node
import React, { useState, useEffect } from 'react';
import { render, Text, Box, useInput, useApp } from 'ink';
import { readFileSync } from 'fs';
import { join } from 'path';
import { themeManager } from './themes/theme-manager.js';
// Read the logo from file
const getLogo = () => {
    const logoPath = join(process.cwd(), 'assets', 'logo.txt');
    const logoContent = readFileSync(logoPath, 'utf8');
    return logoContent.split('\n').filter(line => line.trim());
};
// Custom components for the chat interface
const Logo = ({ theme }) => {
    const [logoLines, setLogoLines] = useState([]);
    useEffect(() => {
        setLogoLines(getLogo());
    }, []);
    return (React.createElement(Box, { flexDirection: "column", alignItems: "center", marginBottom: 2 }, logoLines.map((line, index) => (React.createElement(Text, { key: index, color: theme.colors.primary }, line)))));
};
const Tips = ({ theme }) => (React.createElement(Box, { borderStyle: "round", borderColor: theme.colors.border, paddingX: 1, paddingY: 0, marginBottom: 2 },
    React.createElement(Box, { flexDirection: "column" },
        React.createElement(Text, { color: theme.colors.text, bold: true }, "Tips for getting started:"),
        React.createElement(Text, { color: theme.colors.text }, "1. Ask questions, edit files, or run commands."),
        React.createElement(Text, { color: theme.colors.text }, "2. Be specific for the best results."),
        React.createElement(Text, { color: theme.colors.text },
            "3. ",
            React.createElement(Text, { bold: true }, "/help"),
            " for more information."))));
const ChatMessage = ({ type, content, timestamp, theme }) => {
    const getPrefix = () => {
        switch (type) {
            case 'user':
                return React.createElement(Text, { color: theme.colors.primary }, '>');
            case 'ai':
                return React.createElement(Text, { color: theme.colors.success }, "\u25C6");
            case 'tool':
                return React.createElement(Text, { color: theme.colors.accent }, "\u2190");
            case 'status':
                return React.createElement(Text, { color: theme.colors.warning }, ":");
            default:
                return '';
        }
    };
    return (React.createElement(Box, { marginBottom: 1 },
        React.createElement(Box, { marginRight: 1 }, getPrefix()),
        React.createElement(Box, { flexDirection: "column", flexGrow: 1 },
            React.createElement(Text, { color: theme.colors.text }, content),
            timestamp && (React.createElement(Text, { color: theme.colors.secondary, italic: true }, timestamp)))));
};
const StatusBar = ({ theme }) => (React.createElement(Box, { paddingX: 1, justifyContent: "space-between" },
    React.createElement(Text, { color: theme.colors.text }, "? for shortcuts"),
    React.createElement(Box, null,
        React.createElement(Text, { color: theme.colors.secondary }, theme.name),
        React.createElement(Text, { color: theme.colors.text }, " | "),
        React.createElement(Text, { color: theme.colors.primary }, "cli.tsx"))));
const Help = ({ theme }) => (React.createElement(Box, { flexDirection: "column", marginBottom: 1 },
    React.createElement(Box, { justifyContent: "space-between" },
        React.createElement(Box, { flexDirection: "column", width: "50%" },
            React.createElement(Text, { color: theme.colors.secondary, bold: true }, "Commands/Modes:"),
            React.createElement(Text, { color: theme.colors.secondary }, "! for bash mode"),
            React.createElement(Text, { color: theme.colors.secondary }, "/ for commands"),
            React.createElement(Text, { color: theme.colors.secondary }, "@ for file paths"),
            React.createElement(Text, { color: theme.colors.secondary }, "# to memorize")),
        React.createElement(Box, { flexDirection: "column", width: "50%" },
            React.createElement(Text, { color: theme.colors.secondary, bold: true }, "Shortcuts (? for this help):"),
            React.createElement(Text, { color: theme.colors.secondary }, "double tap esc to clear input"),
            React.createElement(Text, { color: theme.colors.secondary }, "shift + tab to auto-accept edits"),
            React.createElement(Text, { color: theme.colors.secondary }, "ctrl + r for verbose output"),
            React.createElement(Text, { color: theme.colors.secondary }, "option + \u21B5 for newline"),
            React.createElement(Text, { color: theme.colors.secondary }, "ctrl + _ to undo"),
            React.createElement(Text, { color: theme.colors.secondary }, "ctrl + z to suspend")))));
const ExitConfirmation = ({ theme }) => (React.createElement(Box, { flexDirection: "column", marginBottom: 1 },
    React.createElement(Text, { color: theme.colors.secondary }, "Press Ctrl+C again to exit or ESC to cancel")));
const CommandPalette = ({ commands, selectedIndex, theme, scrollOffset }) => {
    const ITEMS_TO_SHOW = 5;
    const visibleCommands = commands.slice(scrollOffset, scrollOffset + ITEMS_TO_SHOW);
    return (React.createElement(Box, { flexDirection: "column", marginBottom: 1 }, visibleCommands.map((command, index) => {
        const actualIndex = scrollOffset + index;
        return (React.createElement(Text, { key: actualIndex, color: actualIndex === selectedIndex ? theme.colors.selection : theme.colors.secondary, bold: actualIndex === selectedIndex },
            command.name,
            " ",
            command.description));
    })));
};
const ThemeSelector = ({ themes, selectedTheme, selectedThemeIndex }) => {
    const selectedThemeObj = themes.find(t => t.name === selectedTheme) || themes[0];
    return (React.createElement(Box, { flexDirection: "row", height: "100%" },
        React.createElement(Box, { flexDirection: "column", width: "50%", paddingX: 1 },
            React.createElement(Box, { marginBottom: 1 },
                React.createElement(Text, { color: "white", bold: true },
                    '>',
                    " Select Theme")),
            React.createElement(Box, { flexDirection: "column", marginBottom: 2 }, themes.map((theme, index) => (React.createElement(Box, { key: index, marginBottom: 1 },
                React.createElement(Text, { color: selectedTheme === theme.name ? "green" : "white", bold: index === selectedThemeIndex },
                    selectedTheme === theme.name ? "●" : "○",
                    " ",
                    theme.name),
                theme.preview && (React.createElement(Box, { marginLeft: 2 },
                    React.createElement(Text, { color: "gray", italic: true }, theme.preview))))))),
            React.createElement(Text, { color: "gray", italic: true }, "(Use \u2191/\u2193 to navigate, Enter to select)"),
            React.createElement(Box, { marginTop: 1 },
                React.createElement(Text, { color: "gray" }, "Esc to cancel"))),
        React.createElement(Box, { flexDirection: "column", width: "50%", paddingX: 1 },
            React.createElement(Box, { marginBottom: 1 },
                React.createElement(Text, { color: "white", bold: true }, "Live Preview")),
            React.createElement(Box, { borderStyle: "round", borderColor: selectedThemeObj?.colors.border || "gray", paddingX: 1, paddingY: 0, flexGrow: 1 },
                React.createElement(Box, { flexDirection: "column" },
                    React.createElement(Box, { flexDirection: "column", alignItems: "center", marginBottom: 1 },
                        React.createElement(Text, { color: selectedThemeObj?.colors.primary || "blue" }, "ZeroIDE")),
                    React.createElement(Box, { borderStyle: "round", borderColor: selectedThemeObj?.colors.border || "gray", paddingX: 1, paddingY: 0, marginBottom: 1 },
                        React.createElement(Text, { color: selectedThemeObj?.colors.text || "white", bold: true }, "Tips:"),
                        React.createElement(Text, { color: selectedThemeObj?.colors.text || "white" }, "Type ? for help")),
                    React.createElement(Box, { marginBottom: 1 },
                        React.createElement(Text, { color: selectedThemeObj?.colors.primary || "blue" }, '>'),
                        React.createElement(Text, { color: selectedThemeObj?.colors.text || "white" }, " User message")),
                    React.createElement(Box, { marginBottom: 1 },
                        React.createElement(Text, { color: selectedThemeObj?.colors.success || "green" }, "\u25C6"),
                        React.createElement(Text, { color: selectedThemeObj?.colors.text || "white" }, " AI response")),
                    React.createElement(Box, { borderStyle: "round", borderColor: selectedThemeObj?.colors.border || "gray", paddingX: 1, paddingY: 0 },
                        React.createElement(Text, { color: selectedThemeObj?.colors.primary || "blue" }, '>'),
                        React.createElement(Text, { color: selectedThemeObj?.colors.input || "white" }, " Type here...")))))));
};
const InputBox = ({ currentInput, placeholder, theme }) => (React.createElement(Box, { borderStyle: "round", borderColor: theme.colors.border, paddingX: 1, paddingY: 0, marginBottom: 1 },
    React.createElement(Text, { color: theme.colors.primary }, '>'),
    React.createElement(Text, { color: theme.colors.input },
        " ",
        currentInput),
    React.createElement(Text, { color: theme.colors.input, inverse: true }, " "),
    !currentInput && (React.createElement(Text, { color: theme.colors.secondary, italic: true },
        " ",
        placeholder))));
const ChatInterface = () => {
    const [messages, setMessages] = useState([]);
    const [currentInput, setCurrentInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [showHelp, setShowHelp] = useState(false);
    const [exitConfirmation, setExitConfirmation] = useState(false);
    const [showCommandPalette, setShowCommandPalette] = useState(false);
    const [selectedCommandIndex, setSelectedCommandIndex] = useState(0);
    const [commandScrollOffset, setCommandScrollOffset] = useState(0);
    const [showThemeSelector, setShowThemeSelector] = useState(false);
    const [selectedTheme, setSelectedTheme] = useState('Default Light');
    const [selectedThemeIndex, setSelectedThemeIndex] = useState(1); // Default Light index
    const [originalTheme, setOriginalTheme] = useState('Default Light'); // Track original theme for ESC
    const { exit: appExit } = useApp();
    // Get current theme object
    const getCurrentTheme = () => {
        const theme = themeManager.getTheme(selectedTheme);
        return theme || themeManager.getTheme('Default Light');
    };
    const commands = [
        { name: '/help', description: 'Show detailed help and documentation' },
        { name: '/select-theme', description: 'Choose a different theme' },
        { name: '/exit', description: 'Exit the application' },
        { name: '/clear', description: 'Clear chat history' },
        { name: '/status', description: 'Show application status' },
        { name: '/version', description: 'Show version information' },
        { name: '/config', description: 'Show configuration' },
        { name: '/about', description: 'About ZeroIDE CLI' }
    ];
    useInput((input, key) => {
        if (key.escape) {
            if (exitConfirmation) {
                setExitConfirmation(false);
            }
            else if (showHelp) {
                setShowHelp(false);
            }
            else if (showCommandPalette) {
                setShowCommandPalette(false);
                setSelectedCommandIndex(0);
            }
            else if (showThemeSelector) {
                // Restore to original theme when ESC is pressed
                themeManager.setActiveTheme(originalTheme);
                setSelectedTheme(originalTheme);
                // Find the index of the original theme
                const allThemes = themeManager.getAllThemes();
                const originalIndex = allThemes.findIndex(t => t.name === originalTheme);
                if (originalIndex !== -1) {
                    setSelectedThemeIndex(originalIndex);
                }
                setShowThemeSelector(false);
            }
            else if (currentInput) {
                // Clear input if there's text
                setCurrentInput('');
            }
            // Don't exit on ESC - only clear input or close dialogs
        }
        // If exit confirmation is active, only handle exit-related inputs
        if (exitConfirmation) {
            if (key.ctrl && input === 'c') {
                appExit();
                return;
            }
            if (input === 'q') {
                appExit();
                return;
            }
            // Any other input cancels the exit confirmation
            setExitConfirmation(false);
            return;
        }
        // Handle Ctrl+C for exit confirmation
        if (key.ctrl && input === 'c') {
            setExitConfirmation(true);
            setShowHelp(false); // Hide help when showing exit confirmation
            setShowCommandPalette(false); // Hide command palette when showing exit confirmation
            return;
        }
        if (input === 'q' && !currentInput) {
            setExitConfirmation(true);
            setShowHelp(false); // Hide help when showing exit confirmation
            setShowCommandPalette(false); // Hide command palette when showing exit confirmation
            return;
        }
        if (input === '?' && !currentInput) {
            setShowHelp(!showHelp);
            setShowCommandPalette(false); // Hide command palette when showing shortcut help
            setExitConfirmation(false); // Hide exit confirmation when showing help
            return;
        }
        // Show command palette when "/" is typed
        if (input === '/' && !currentInput) {
            setShowCommandPalette(true);
            setShowHelp(false); // Hide help when showing command palette
            setExitConfirmation(false); // Hide exit confirmation when showing command palette
            setSelectedCommandIndex(0);
            setCommandScrollOffset(0);
            setCurrentInput('/'); // Add / to input
            return;
        }
        // Handle command palette navigation
        if (showCommandPalette) {
            if (key.upArrow) {
                setSelectedCommandIndex(prev => {
                    const newIndex = prev > 0 ? prev - 1 : commands.length - 1;
                    // Adjust scroll offset if needed
                    if (newIndex < commandScrollOffset) {
                        setCommandScrollOffset(Math.max(0, newIndex));
                    }
                    return newIndex;
                });
                return;
            }
            if (key.downArrow) {
                setSelectedCommandIndex(prev => {
                    const newIndex = prev < commands.length - 1 ? prev + 1 : 0;
                    // Adjust scroll offset if needed
                    if (newIndex >= commandScrollOffset + 5) {
                        setCommandScrollOffset(Math.min(commands.length - 5, newIndex - 4));
                    }
                    return newIndex;
                });
                return;
            }
            if (key.return) {
                const selectedCommand = commands[selectedCommandIndex];
                if (selectedCommand) {
                    if (selectedCommand.name === '/help') {
                        // Add help dialog logic here
                        const newMessage = {
                            type: 'status',
                            content: 'Help dialog coming soon!',
                            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        setMessages(prev => [...prev, newMessage]);
                    }
                    else if (selectedCommand.name === '/select-theme') {
                        // Save the current theme as original before opening selector
                        const currentTheme = themeManager.getActiveTheme();
                        if (currentTheme) {
                            setOriginalTheme(currentTheme.name);
                            // Find the index of the current theme
                            const allThemes = themeManager.getAllThemes();
                            const currentIndex = allThemes.findIndex(t => t.name === currentTheme.name);
                            if (currentIndex !== -1) {
                                setSelectedThemeIndex(currentIndex);
                                setSelectedTheme(currentTheme.name);
                            }
                        }
                        setShowThemeSelector(true);
                    }
                    else if (selectedCommand.name === '/exit') {
                        // Exit the application
                        appExit();
                    }
                }
                else {
                    // Unknown command - show error message
                    const newMessage = {
                        type: 'status',
                        content: `Command not found: ${currentInput}`,
                        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                    };
                    setMessages(prev => [...prev, newMessage]);
                }
                setShowCommandPalette(false);
                setSelectedCommandIndex(0);
                setCurrentInput('');
                return;
            }
        }
        // Handle theme selector navigation
        if (showThemeSelector) {
            const allThemes = themeManager.getAllThemes();
            if (key.upArrow) {
                const newIndex = selectedThemeIndex > 0 ? selectedThemeIndex - 1 : allThemes.length - 1;
                setSelectedThemeIndex(newIndex);
                // Update the selected theme name as we navigate
                const theme = allThemes[newIndex];
                if (theme) {
                    setSelectedTheme(theme.name);
                }
                return;
            }
            if (key.downArrow) {
                const newIndex = selectedThemeIndex < allThemes.length - 1 ? selectedThemeIndex + 1 : 0;
                setSelectedThemeIndex(newIndex);
                // Update the selected theme name as we navigate
                const theme = allThemes[newIndex];
                if (theme) {
                    setSelectedTheme(theme.name);
                }
                return;
            }
            if (key.return) {
                const theme = allThemes[selectedThemeIndex];
                if (theme) {
                    // Apply the theme permanently
                    themeManager.setActiveTheme(theme.name);
                    setShowThemeSelector(false); // Close the dialog after selection
                    // Add a confirmation message
                    const newMessage = {
                        type: 'status',
                        content: `Theme changed to: ${theme.name}`,
                        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                    };
                    setMessages(prev => [...prev, newMessage]);
                }
                return;
            }
        }
        if (key.return && currentInput.trim()) {
            // Add user message
            const newMessage = {
                type: 'user',
                content: currentInput,
                timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
            };
            setMessages(prev => [...prev, newMessage]);
            setCurrentInput('');
            setIsLoading(true);
            // Simulate AI response after a delay
            setTimeout(() => {
                const aiResponse = {
                    type: 'ai',
                    content: `I understand you're asking about "${newMessage.content}". Let me help you with that.`,
                    timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                };
                setMessages(prev => [...prev, aiResponse]);
                setIsLoading(false);
            }, 2000);
        }
        else if (key.backspace || key.delete) {
            const newInput = currentInput.slice(0, -1);
            setCurrentInput(newInput);
            // Hide command palette if / is deleted
            if (showCommandPalette && !newInput.startsWith('/')) {
                setShowCommandPalette(false);
                setSelectedCommandIndex(0);
            }
            // Auto-select command based on input
            if (showCommandPalette && newInput.startsWith('/')) {
                const searchTerm = newInput.slice(1).toLowerCase();
                const matchingIndex = commands.findIndex(cmd => cmd.name.toLowerCase().includes(searchTerm) ||
                    cmd.description.toLowerCase().includes(searchTerm));
                setSelectedCommandIndex(matchingIndex >= 0 ? matchingIndex : -1); // -1 means no selection
            }
        }
        else if (input && input.length === 1) {
            const newInput = currentInput + input;
            setCurrentInput(newInput);
            // Auto-select command based on input
            if (showCommandPalette && newInput.startsWith('/')) {
                const searchTerm = newInput.slice(1).toLowerCase();
                const matchingIndex = commands.findIndex(cmd => cmd.name.toLowerCase().includes(searchTerm) ||
                    cmd.description.toLowerCase().includes(searchTerm));
                setSelectedCommandIndex(matchingIndex >= 0 ? matchingIndex : -1); // -1 means no selection
            }
        }
    });
    const currentTheme = getCurrentTheme();
    return (React.createElement(Box, { flexDirection: "column", height: "100%", padding: 1 },
        !showThemeSelector && (React.createElement(React.Fragment, null,
            React.createElement(Logo, { theme: currentTheme }),
            React.createElement(Tips, { theme: currentTheme }),
            React.createElement(Box, { flexDirection: "column", flexGrow: 1, marginBottom: 2 },
                messages.map((message, index) => (React.createElement(ChatMessage, { key: index, type: message.type, content: message.content, timestamp: message.timestamp, theme: currentTheme }))),
                isLoading && (React.createElement(Box, { marginBottom: 1 },
                    React.createElement(Text, { color: currentTheme.colors.warning }, ":"),
                    React.createElement(Text, { color: currentTheme.colors.text }, " Processing your request"),
                    React.createElement(Text, { color: currentTheme.colors.secondary }, " (esc to cancel, 2s)")))),
            React.createElement(InputBox, { currentInput: currentInput, placeholder: "Type your message...", theme: currentTheme }),
            showHelp && React.createElement(Help, { theme: currentTheme }),
            showCommandPalette && React.createElement(CommandPalette, { commands: commands, selectedIndex: selectedCommandIndex, theme: currentTheme, scrollOffset: commandScrollOffset }),
            exitConfirmation && React.createElement(ExitConfirmation, { theme: currentTheme }),
            React.createElement(StatusBar, { theme: currentTheme }))),
        showThemeSelector && (React.createElement(Box, { borderStyle: "round", borderColor: "gray", padding: 2, marginBottom: 2 },
            React.createElement(ThemeSelector, { themes: themeManager.getAllThemes(), selectedTheme: selectedTheme, selectedThemeIndex: selectedThemeIndex })))));
};
render(React.createElement(ChatInterface, null), { exitOnCtrlC: false });
